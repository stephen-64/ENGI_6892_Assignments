# Generated by Haxe 4.0.0-preview.4+1e3e5e016
# coding: utf-8



class Parser:
    __slots__ = ("wordlist", "wordlistcopy", "removed_words", "f")

    def __init__(self,wordlist = None):
        self.f = False
        self.removed_words = list()
        self.wordlistcopy = list()
        self.wordlist = list()
        if (wordlist is not None):
            self.wordlist = wordlist
            self.wordlistcopy = list()
            _g = 0
            _g1 = self.wordlist
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = self.wordlistcopy
                _this.append(s)

    def set_word(self,wordlist):
        self.wordlist = wordlist
        self.wordlistcopy = list()
        _g = 0
        _g1 = self.wordlist
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.wordlistcopy
            _this.append(s)

    def parse(self):
        self.f = self.run_parser()
        return self.f

    def consume(self,string):
        _this = self.removed_words
        _this.append(string)
        python_internal_ArrayImpl.remove(self.wordlist,string)

    def restore(self):
        _g = 0
        _g1 = self.removed_words
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.wordlist.insert(0, s)
        self.removed_words = list()

    def clear_restore(self):
        self.removed_words = list()

    def restore_array(self):
        self.wordlist = list()
        _g = 0
        _g1 = self.wordlistcopy
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.wordlist
            _this.append(s)

    def run_parser(self):
        if ((self.comp() and self.id()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if ((self.opercomp() and self.b()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if (self.b() and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if ((self.logic() and self.compar()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if (self.sb() and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if ((self.loops() and self.compar()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if ((self.opercomp() and self.operat()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if ((self.operb() and self.compoper()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if ((self.b() and self.compoper()) and ((len(self.wordlist) == 0))):
            return True
        self.restore_array()
        self.clear_restore()
        if (self.operat() and self.bcomp()):
            return True
        return False

    def bcomp(self):
        if (self.relop() and self.id()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def operb(self):
        if (self.b() and self.op()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def compoper(self):
        if (((self.comp() or self.relop())) and self.operat()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def logic(self):
        if (self.compar() and self.predop()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def compar(self):
        if (self.comp() and ((self.id() or self.num()))):
            self.clear_restore()
            return True
        self.restore()
        return False

    def opercomp(self):
        if (self.operat() and self.relop()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def operat(self):
        if (self.oper() and ((self.id() or self.num()))):
            self.clear_restore()
            return True
        self.restore()
        return False

    def oper(self):
        if (self.id() and self.op()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def comp(self):
        if (self.id() and self.relop()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def logicb(self):
        if (self.logic() and ((self.comparb() or self.opcomp()))):
            self.clear_restore()
            return True
        self.restore()
        return False

    def comparb(self):
        if (self.compar() and self.b()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def b(self):
        if (((self.ob() or self.check_lb())) and self.cb()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def sb(self):
        if (self.sob() and self.scb()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def sob(self):
        if (((self.logic() or self.loops())) and self.check_slb()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def loops(self):
        if (self.loop() and self.check_col()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def loop(self):
        if (self.quant() and self.id()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def scb(self):
        if (((self.logicb() or self.loopar())) and self.check_srb()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def loopar(self):
        if (self.loops() and self.compar()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def opcomp(self):
        if (self.oper() and self.comparant()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def comparant(self):
        if (self.comp() and self.num()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def ob(self):
        if ((((self.oper() or self.comp()) or self.op())) and self.check_lb()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def cb(self):
        if (self.operat() and self.check_rb()):
            self.clear_restore()
            return True
        self.restore()
        return False

    def id(self):
        _hx_list = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if (len(string) > 1):
            holder = False
            _g1 = 0
            _g = len(string)
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                holder = False
                _g2 = 0
                while (_g2 < len(_hx_list)):
                    s = (_hx_list[_g2] if _g2 >= 0 and _g2 < len(_hx_list) else None)
                    _g2 = (_g2 + 1)
                    if ((("" if (((i < 0) or ((i >= len(string))))) else string[i])) == s):
                        holder = True
            if (holder == True):
                self.consume(string)
                return True
            else:
                return False
        else:
            _g3 = 0
            while (_g3 < len(_hx_list)):
                s1 = (_hx_list[_g3] if _g3 >= 0 and _g3 < len(_hx_list) else None)
                _g3 = (_g3 + 1)
                if (string == s1):
                    self.consume(string)
                    return True
            return False

    def num(self):
        _hx_list = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if (len(string) > 1):
            holder = False
            _g1 = 0
            _g = len(string)
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                holder = False
                _g2 = 0
                while (_g2 < len(_hx_list)):
                    s = (_hx_list[_g2] if _g2 >= 0 and _g2 < len(_hx_list) else None)
                    _g2 = (_g2 + 1)
                    if ((("" if (((i < 0) or ((i >= len(string))))) else string[i])) == s):
                        holder = True
            if (holder == True):
                self.consume(string)
                return True
            else:
                return False
        else:
            _g3 = 0
            while (_g3 < len(_hx_list)):
                s1 = (_hx_list[_g3] if _g3 >= 0 and _g3 < len(_hx_list) else None)
                _g3 = (_g3 + 1)
                if (string == s1):
                    self.consume(string)
                    return True
            return False

    def op(self):
        _hx_list = ["-", "+", "*", "/"]
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        _g = 0
        while (_g < len(_hx_list)):
            s = (_hx_list[_g] if _g >= 0 and _g < len(_hx_list) else None)
            _g = (_g + 1)
            if (string == s):
                self.consume(string)
                return True
        return False

    def relop(self):
        _hx_list = ["=", "<", ">", "<=", ">="]
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        _g = 0
        while (_g < len(_hx_list)):
            s = (_hx_list[_g] if _g >= 0 and _g < len(_hx_list) else None)
            _g = (_g + 1)
            if (string == s):
                self.consume(string)
                return True
        return False

    def predop(self):
        _hx_list = ["AND", "OR", "IMP"]
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        _g = 0
        while (_g < len(_hx_list)):
            s = (_hx_list[_g] if _g >= 0 and _g < len(_hx_list) else None)
            _g = (_g + 1)
            if (string == s):
                self.consume(string)
                return True
        return False

    def quant(self):
        _hx_list = ["FORALL", "EXISTS"]
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        _g = 0
        while (_g < len(_hx_list)):
            s = (_hx_list[_g] if _g >= 0 and _g < len(_hx_list) else None)
            _g = (_g + 1)
            if (string == s):
                self.consume(string)
                return True
        return False

    def check_rb(self):
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if ((self.wordlist[0] if 0 < len(self.wordlist) else None) == ")"):
            self.consume(string)
            return True
        return False

    def check_lb(self):
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if ((self.wordlist[0] if 0 < len(self.wordlist) else None) == "("):
            self.consume(string)
            return True
        return False

    def check_srb(self):
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if ((self.wordlist[0] if 0 < len(self.wordlist) else None) == "]"):
            self.consume(string)
            return True
        return False

    def check_slb(self):
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if ((self.wordlist[0] if 0 < len(self.wordlist) else None) == "["):
            self.consume(string)
            return True
        return False

    def check_col(self):
        string = (self.wordlist[0] if 0 < len(self.wordlist) else None)
        if (string == "::"):
            self.consume(string)
            return True
        return False



class Question1b:
    __slots__ = ()

    @staticmethod
    def main():
        parser = Parser()
        parser.set_word(["x", ">", "y"])
        holder = parser.parse()
        if (holder == True):
            print("Test 1: Pass")
        else:
            print("Test 1: Failed")
        parser.set_word(["x"])
        holder = parser.parse()
        if (holder == False):
            print("Test 2: Pass")
        else:
            print("Test 2: Failed")
        parser.set_word(["x", "+", "y"])
        holder = parser.parse()
        if (holder == False):
            print("Test 3: Pass")
        else:
            print("Test 3: Failed")
        parser.set_word(["x", "+", "y", ">=", "x", "*", "(", "y", "-", "3", ")"])
        holder = parser.parse()
        if (holder == True):
            print("Test 4: Pass")
        else:
            print("Test 4: Failed")
        parser.set_word(["y", ">", "(", "y", "-", "3", ")"])
        holder = parser.parse()
        if (holder == True):
            print("Test 5: Pass")
        else:
            print("Test 5: Failed")
        parser.set_word(["x", "<", "y", "AND", "y", "<", "z"])
        holder = parser.parse()
        if (holder == True):
            print("Test 6: Pass")
        else:
            print("Test 6: Failed")
        parser.set_word(["x", ">", "y", "AND", "[", "y", "=", "z", "OR", "y", "=", "z", "*", "(", "x", "+", "1", ")", "]"])
        holder = parser.parse()
        if (holder == True):
            print("Test 7: Pass")
        else:
            print("Test 7: Failed")
        parser.set_word(["x", ">", "y", "AND", "[", "y", "=", "z", "OR", "y", "=", "z", "*", "(", "x", "+", "1", ")", "]"])
        holder = parser.parse()
        if (holder == True):
            print("Test 8: Pass")
        else:
            print("Test 8: Failed")
        parser.set_word(["FORALL", "x", "::", "[", "x", "<", "5", "IMP", "x", "*", "x", "<", "25", "]"])
        holder = parser.parse()
        if (holder == True):
            print("Test 9: Pass")
        else:
            print("Test 9: Failed")
        parser.set_word(["FORALL", "x", "::", "x", ">", "y"])
        holder = parser.parse()
        if (holder == True):
            print("Test 10: Pass")
        else:
            print("Test 10: Failed")
        parser.set_word(["FORALL", "x", "::", "[", "x", "AND", "y", "]"])
        holder = parser.parse()
        if (holder == False):
            print("Test 11: Pass")
        else:
            print("Test 11: Failed")
        parser.set_word(["EXISTS", "y", "::", "[", "FORALL", "x", "::", "x", ">", "y", "]"])
        holder = parser.parse()
        if (holder == True):
            print("Test 12: Pass")
        else:
            print("Test 12: Failed")
        parser.set_word(["EXISTS", "y", "::", "[", "FORALL", "x", "::", "x", ">", "y"])
        holder = parser.parse()
        if (holder == False):
            print("Test 13: Pass")
        else:
            print("Test 13: Failed")
        parser.set_word(["x", "+", "y", ">", "yz", "+", "xxx"])
        holder = parser.parse()
        if (holder == True):
            print("Test 14: Pass")
        else:
            print("Test 14: Failed")
        parser.set_word(["(", "x", "+", "y", ")", "*", "z", ">", "yz", "+", "xxx"])
        holder = parser.parse()
        if (holder == True):
            print("Test 15: Pass")
        else:
            print("Test 15: Failed")
        parser.set_word(["(", "x", "+", "y", "*", "z", ">", "yz", "+", "xxx"])
        holder = parser.parse()
        if (holder == False):
            print("Test 16: Pass")
        else:
            print("Test 16: Failed")
        parser.set_word(["x", "+", "(", "y", "*", "z", ")", ">", "yz", "+", "xxx"])
        holder = parser.parse()
        if (holder == True):
            print("Test 17: Pass")
        else:
            print("Test 17: Failed")
        parser.set_word(["x", "*", "y", "=", "qr"])
        holder = parser.parse()
        if (holder == True):
            print("Test 18: Pass")
        else:
            print("Test 18: Failed")
        parser.set_word(["x", "y"])
        holder = parser.parse()
        if (holder == False):
            print("Test 19: Pass")
        else:
            print("Test 19: Failed")


class python_internal_ArrayImpl:
    __slots__ = ()

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None


class python_internal_MethodClosure:
    __slots__ = ("obj", "func")

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)




if __name__ == '__main__':
    Question1b.main()
